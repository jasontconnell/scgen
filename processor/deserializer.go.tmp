package processor

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"scgen/conf"
	"scgen/model"
	"strconv"
	"strings"
)

var itemregex *regexp.Regexp = regexp.MustCompile(`ID: (.*?)\r\nName: (.*?)\r\nTemplateID: (.*?)\r\nParentID: (.*?)\r\nMasterID: (.*?)\n`)
var fieldregex *regexp.Regexp = regexp.MustCompile(`(?s)__FIELD__\r\nID: (.*?)\r\nName: (.*?)\r\nVersion: (.*?)\r\nLanguage: (.*?)\r\nSource: (.*?)\r\n__VALUESTART__\r\n(.*?)\r\n___VALUEEND___\r\n\r\n`)

func getItemsForDeserialization(cfg conf.Configuration) []model.DeserializedItem {
	list := []model.DeserializedItem{}
	filepath.Walk(cfg.SerializationPath, func(path string, info os.FileInfo, err error) error {
		if strings.HasSuffix(path, "."+cfg.SerializationExtension) {
			bytes, _ := ioutil.ReadFile(path)
			contents := string(bytes)
			if itemmatches := itemregex.FindAllStringSubmatch(contents, -1); len(itemmatches) == 1 {
				m := itemmatches[0]
				id := m[1]
				name := m[2]
				template := m[3]
				parent := m[4]
				master := m[5]

				item := model.DeserializedItem{ID: id, TemplateID: template, ParentID: parent, Name: name, MasterID: master, Fields: []model.DeserializedField{}}

				if fieldmatches := fieldregex.FindAllStringSubmatch(contents, -1); len(fieldmatches) > 0 {
					for _, m := range fieldmatches {
						id := m[1]
						name := m[2]
						version, _ := strconv.ParseInt(m[3], 10, 64)
						language := m[4]
						source := m[5]
						value := m[6]

						item.Fields = append(item.Fields, model.DeserializedField{ID: id, Name: name, Version: version, Language: language, Source: source, Value: value})
					}
				}
				list = append(list, item)
			}
		}

		return nil
	})

	return list
}

func filterUpdateItems(filteredMap map[string]*model.Item, serialList []*model.SerializedItem, deserialList []model.DeserializedItem) ([]model.UpdateItem, []model.UpdateField) {
	updateItems := []model.UpdateItem{}
	updateFields := []model.UpdateField{}
	itemMap := make(map[string]*model.SerializedItem)
	fieldMap := make(map[string]model.SerializedField)

	for _, sitem := range serialList {
		itemMap[sitem.Item.ID] = sitem
		for _, field := range sitem.Fields {
			key := fmt.Sprintf("%v_%v", sitem.Item.ID, field.FieldID)
			fieldMap[key] = field
		}
	}

	deserializedItemMap := make(map[string]model.DeserializedItem)
	deserializedFieldMap := make(map[string]model.DeserializedField)

	for _, ditem := range deserialList {
		deserializedItemMap[ditem.ID] = ditem
		for _, dfield := range ditem.Fields {
			key := fmt.Sprintf("%v_%v", ditem.ID, dfield.ID)
			deserializedFieldMap[key] = dfield
		}
	}

	for _, sitem := range serialList {
		_, inFilter := filteredMap[sitem.Item.ID]
		if _, ok := deserializedItemMap[sitem.Item.ID]; !ok && inFilter {
			updateItems = append(updateItems, model.UpdateItem{ID: sitem.Item.ID, Name: sitem.Item.Name, TemplateID: sitem.Item.TemplateID, ParentID: sitem.Item.ParentID, MasterID: sitem.Item.MasterID, UpdateType: model.Delete})

			for _, sfield := range sitem.Fields {
				updateFields = append(updateFields, model.UpdateField{ItemID: sitem.Item.ID, FieldID: sfield.FieldID, Value: sfield.Value, Source: sfield.Source, Version: sfield.Version, Language: sfield.Language, UpdateType: model.Delete})
			}
		}
	}

	for _, ditem := range deserialList {
		if item, ok := itemMap[ditem.ID]; !ok {
			updateItems = append(updateItems, model.UpdateItem{ID: ditem.ID, Name: ditem.Name, TemplateID: ditem.TemplateID, ParentID: ditem.ParentID, MasterID: ditem.MasterID, UpdateType: model.Insert})
			for _, field := range ditem.Fields {
				updateFields = append(updateFields, model.UpdateField{ItemID: ditem.ID, FieldID: field.ID, Value: field.Value, Source: field.Source, Version: field.Version, Language: field.Language, UpdateType: model.Insert})
			}
		} else {
			for _, field := range ditem.Fields {
				key := fmt.Sprintf("%v_%v", ditem.ID, field.ID)
				if existingField, ok := fieldMap[key]; !ok {
					updateFields = append(updateFields, model.UpdateField{ItemID: ditem.ID, FieldID: field.ID, Value: field.Value, Source: field.Source, Version: field.Version, Language: field.Language, UpdateType: model.Insert})
				} else {
					if existingField.Value != field.Value || existingField.Version != field.Version || existingField.Language != field.Language {
						updateFields = append(updateFields, model.UpdateField{ItemID: item.Item.ID, FieldID: field.ID, Value: field.Value, Source: field.Source, Version: field.Version, Language: field.Language, UpdateType: model.Update})
					}
				}
			}

			if item.Item.Name != ditem.Name || item.Item.TemplateID != ditem.TemplateID || item.Item.MasterID != ditem.MasterID || item.Item.ParentID != ditem.ParentID {
				updateItems = append(updateItems, model.UpdateItem{ID: ditem.ID, Name: ditem.Name, TemplateID: ditem.TemplateID, ParentID: ditem.ParentID, MasterID: ditem.MasterID, UpdateType: model.Update})

				//fmt.Println("item found in db, updating", ditem.ID)
			}
		}
	}
	return updateItems, updateFields
}
